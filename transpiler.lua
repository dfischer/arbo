local module = {}

local lume = require('lume')


local function line(indent, format, ...)
  io.write(string.rep('  ', indent), string.format(format, ...), '\n')
end

local function stackPush(indent)
  line(indent, 'table.insert(stack, {x, y, node})')
end

local function stackPop(indent)
  line(indent, 'x, y, node = unpack(stack[#stack])')
  line(indent, 'stack[#stack] = nil')
end

local handlers = {}

function walk(node, depth)
  if depth > 15 then
    line(depth, '-- too deep, stopping here')
    return
  end
  if not node[1] or not handlers[node[1]] then
    print('---ERROR--')
    print('node', node)
    print('node[1]', node[1])
    print('handlers[node[1]]', handlers[node[1]])
  else
    line(depth, '-- %s - {%s ...}', tostring(node), tostring(node[1]))
    handlers[node[1]](node, depth, indent)
  end
end

function module.process(node)
  local file = io.open('gen.lua', 'w')
  io.output('gen.lua')
  line(0, '-- autogenerated code')
  line(0, 'local noise = require("noise")')
  line(0, 'local r = {0, 0, 0, 0}')
  line(0, '')
  line(0, 'function gentrace(node, x, y)')
    line(1, 'local stack = {}')
    --line(1, 'local depth = 0')
    line(1, 'r[1], r[2], r[3], r[4] = 0, 1, 1, 0')
  walk(node, 1)
    line(1, 'return r')
  line(0, 'end')
  line(0, 'return gentrace')
  io.close()
  lume.hotswap('gen')
end

-- node handlers

function handlers.edge(node, depth)
  local off = node[2] or 0
  local mul = node[3] or 1
  line(depth, 'r[4] = .5 - (%f + y ) * 100 * %f', off, mul)
end

function handlers.simplex(node, depth)
  local off = node[2] or 0
  local mul = node[3] or 1
  line(depth, 'r[4] =  (%f + noise.Simplex2D(x, y)) * %f', off, mul)
end

function handlers.wrap(node, depth)
  line(depth, 'x, y = -math.atan2(y, x) / math.pi, (x^2 + y^2) - 1')
  line(depth, 'node = node[2]')
  walk(node[2], depth + 1)
end

function handlers.tint(node, depth)
  line(depth, 'node = node[3]')
  walk(node[3], depth + 1)
  local a = node[2][4] or 1
  if a == 1 then
    line(depth, 'r[1] = %s or r[1]', tostring(node[2][1]))
    line(depth, 'r[2] = %s or r[2]', tostring(node[2][2]))
    line(depth, 'r[3] = %s or r[3]', tostring(node[2][3]))
  else
    line(depth, 'r[1] = r[1] * %f + (%s or r[1]) * %f', (1 - a), tostring(node[2][1]), a)
    line(depth, 'r[2] = r[2] * %f + (%s or r[2]) * %f', (1 - a), tostring(node[2][2]), a)
    line(depth, 'r[3] = r[3] * %f + (%s or r[3]) * %f', (1 - a), tostring(node[2][3]), a)
  end
end

function handlers.negate(node, depth)
  line(depth, 'node = node[2]')
  walk(node[2], depth + 1)
  line(depth, 'r[4] = 1 - r[4]')
end

function handlers.position(node, depth)
  line(depth, 'x, y = getTransform(node):transformPoint(x, y)')
  line(depth, 'node = node[3]')
  walk(node[3], depth + 1)
end

function handlers.combine(node, depth)
  for i = 2, #node do
    line(depth, 'if r[4] < 0.05 then')
    stackPush(depth+1)
    line(depth+1, 'node = node[%d]', i)
    walk(node[i], depth + 1)
    stackPop(depth+1)
    line(depth, 'end')
  end
end

function handlers.clip(node, depth)
  line(depth, 'local minA = math.huge')
  for i = 2, #node do
    stackPush(depth)
    line(depth, 'node = node[%d]', i)
    walk(node[i], depth + 1)
    line(depth, 'r[4] = math.min(r[4], minA)', i)
    line(depth, 'minA = math.min(r[4], minA)', i)
    stackPop(depth)
  end
end

function handlers.memo(node, depth)
  line(depth, 'r[1], r[2], r[3], r[4] = unpack(memoLookup(node, %f, x, y))', node[2])
end

return module